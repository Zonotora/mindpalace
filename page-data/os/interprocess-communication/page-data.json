{"componentChunkName":"component---src-templates-file-js","path":"/os/interprocess-communication","result":{"data":{"markdownRemark":{"html":"<h1 id=\"Critical-regions\">Critical regions</h1>\n<p>Race conditions arise when multiple processes want the modify the same resources. To avoid this we need some way to prohibit processes to modify some resource if that is already being modified by another process. This concept is called \n          <span class=\"keyword-link\" id=\"keyword-link-mutual exclusion\">\n          mutual exclusion\n          </span>\n          . A critical region/section is defined as the part of the program that could lead to race conditions, in other words the part which access the shared memory. To have a good solution to the critical section problem we need four conditions to hold</p>\n<ol>\n<li>Only one process may access the critical region at a time</li>\n<li>No assumptions should be made on the hardware (speeds and number of CPUs)</li>\n<li>A process running outside its critical region should not block any other process</li>\n<li>A process should not have to wait forever to enter its critical region</li>\n</ol>\n<h1 id=\"Mutual-exclusion-with-busy-waiting\">Mutual exclusion with busy waiting</h1>\n<p>On a single-processor system one easy way to accomplish this is to disable clock interrupts just after entering the critical region and enable them just before leaving. With no clock interrupts the CPU will not switch to another process. Thus the process can be sure that it is the only process accessing the shared resource. However it is not an elegant solution to give user processes the power to disable clock interrupts, because one may never turn them on again. Also, with more CPUs disabling the interrupts will only disable them for the current CPU. Although the kernel itself may very well use this method for convenience when updating different data structures. But more sophisticated methods are needed for synchronization. Another solution may be to take turns with for example a variable that tells whether a process may enter its critical region, if it can't it just spins. This is not a good solution if the processes are running with different speed, because then the faster process needs to wait for the slower all the time. The following is Petersons's solution to mutual exclusion which avoids taking turns:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">FALSE</span>  <span class=\"token expression\"><span class=\"token number\">0</span></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">TRUE</span> <span class=\"token expression\"><span class=\"token number\">1</span></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">N</span> <span class=\"token expression\"><span class=\"token number\">2</span> </span><span class=\"token comment\">/* number of processes */</span></span>\n<span class=\"token keyword\">int</span> turn<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* whose turn is it? */</span>\n<span class=\"token keyword\">int</span> interested<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* all values initially 0 (FALSE) */</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">enter_region</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> process<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* process is 0 or 1 */</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> other<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* number of the other process */</span>\n    other <span class=\"token operator\">=</span> <span class=\"token number\">1</span> âˆ’ process<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* the opposite of process */</span>\n    interested<span class=\"token punctuation\">[</span>process<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> TRUE<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* show that you are interested */</span>\n    turn <span class=\"token operator\">=</span> process<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* set flag */</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>turn <span class=\"token operator\">==</span> process <span class=\"token operator\">&amp;&amp;</span> interested<span class=\"token punctuation\">[</span>other<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> TRUE<span class=\"token punctuation\">)</span>  <span class=\"token comment\">/* null statement */</span> <span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">leave_region</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> process<span class=\"token punctuation\">)</span> <span class=\"token comment\">/* process: who is leaving */</span>\n<span class=\"token punctuation\">{</span>\n    interested<span class=\"token punctuation\">[</span>process<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> FALSE<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* indicate departure from critical region */</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"Hardware-instructions\">Hardware instructions</h2>\n<p>Many processors nowadays support intructions that are \n          <span class=\"keyword-link\" id=\"keyword-link-atomic\">\n          atomic\n          </span>\n          . This instruction is the TSL (Test and Set Lock). The instruction guarantees that no other process can access the memory word until the instruction has finished, so the instruction effectively blocks the memeory bus until it is finished to prohibit other processes to access it while it is active. XCHG is another such instruction which exchanges the contents of two locations in an atomic way.</p>\n<h1 id=\"Mutual-exclusion-that-blocks\">Mutual exclusion that blocks</h1>\n<p>To avoid wasting CPU resources when a process is waiting for the lock we need to come up with another solution. A simple solution is to use <code class=\"language-text\">sleep()</code> and <code class=\"language-text\">wakeup()</code></p>\n<h1 id=\"Semaphores\">Semaphores</h1>\n<p>A semaphore has a value where 0 represent that no wakeups were saved or above 0 which indicates that more than 0 wakeups are pending. Usually incrementing and decrementing are done through operations called <code class=\"language-text\">up</code> and <code class=\"language-text\">down</code>. These actions are executed in an atomic manner. The normal way to implement them as that is through system calls with the operating system briefly disabling all the interrupts while accessing the semaphore. Disabling all interrupts here should be of no harm because the access is only a few instructions. If the processor consists of multiple CPUs each semaphore should be protected by a lock variable as well with the hardware instructions (e.g. <code class=\"language-text\">TSL</code>).</p>\n<h1 id=\"Mutex\">Mutex</h1>\n<p>A mutex is a simplified version of a semaphore when counting is not needed. They are only good for managing mutual exclusion. They can have two states: unlocked or locked. They can be implemented in user space if hardware instructions like <code class=\"language-text\">TSL</code> are available.</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">mutex_lock:\n    TSL REGISTER,MUTEX      % copy mutex to register and set mutex to 1\n    CMP REGISTER,#0         % was mutex zero?\n    JZE ok                  % if it was zero, mutex was unlocked, so return\n    CALL thread_yield       % mutex is busy; schedule another thread\n    JMP mutex_lock          % try again\nok: RET                     % retur n to caller; critical region entered\n\nmutex_unlock:\n    MOVE MUTEX,#0           % store a 0 in mutex\n    RET                     % retur n to caller</code></pre></div>\n<p>We can see that if a process can not acquire the mutex, it will yield instead of busy waiting. This is especially important in user threads, because there is no clock that could stop threads that have run for too long. Thus a thread trying to acquire a lock by busy waiting will run forever and never acquire the lock, blocking other threads from being run.</p>\n<h1 id=\"Avoid-locks\">Avoid locks</h1>\n<p>We could let readers read the old or new version of the modified shared data while a writer writes to it, instead of a weird combiation.</p>\n<div class=\"reference-items\"></div>","frontmatter":{"slug":"/os/interprocess-communication","tags":[],"lastModified":"2021-10-04","created":"2021-09-28","title":"Interprocess Communication","header":[{"depth":1,"name":"Critical regions","link":"Critical-regions"},{"depth":1,"name":"Mutual exclusion with busy waiting","link":"Mutual-exclusion-with-busy-waiting"},{"depth":2,"name":"Hardware instructions","link":"Hardware-instructions"},{"depth":1,"name":"Mutual exclusion that blocks","link":"Mutual-exclusion-that-blocks"},{"depth":1,"name":"Semaphores","link":"Semaphores"},{"depth":1,"name":"Mutex","link":"Mutex"},{"depth":1,"name":"Avoid locks","link":"Avoid-locks"}]}}},"pageContext":{"slug":"/os/interprocess-communication"}},"staticQueryHashes":[]}