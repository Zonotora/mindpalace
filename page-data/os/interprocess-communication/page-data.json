{"componentChunkName":"component---src-templates-file-js","path":"/os/interprocess-communication","result":{"data":{"markdownRemark":{"html":"<h1 id=\"Critical-regions\">Critical regions</h1>\n<p>Race conditions arise when multiple processes want the modify the same resources. To avoid this we need some way to prohibit processes to modify some resource if that is already being modified by another process. This concept is called \n          <span class=\"keyword-link\" id=\"keyword-link-mutual exclusion\">\n          mutual exclusion\n          </span>\n          . A critical region/section is defined as the part of the program that could lead to race conditions, in other words the part which access the shared memory. To have a good solution to the critical section problem we need four conditions to hold</p>\n<ol>\n<li>Only one process may access the critical region at a time</li>\n<li>No assumptions should be made on the hardware (speeds and number of CPUs)</li>\n<li>A process running outside its critical region should not block any other process</li>\n<li>A process should not have to wait forever to enter its critical region</li>\n</ol>\n<h1 id=\"Mutual-exclusion-with-busy-waiting\">Mutual exclusion with busy waiting</h1>\n<p>On a single-processor system one easy way to accomplish this is to disable clock interrupts just after entering the critical region and enable them just before leaving. With no clock interrupts the CPU will not switch to another process. Thus the process can be sure that it is the only process accessing the shared resource. However it is not an elegant solution to give user processes the power to disable clock interrupts, because one may never turn them on again. Also, with more CPUs disabling the interrupts will only disable them for the current CPU. Although the kernel itself may very well use this method for convenience when updating different data structures. But more sophisticated methods are needed for synchronization. Another solution may be to take turns with for example a variable that tells whether a process may enter its critical region, if it can't it just spins. This is not a good solution if the processes are running with different speed, because then the faster process needs to wait for the slower all the time. The following is Petersons's solution to mutual exclusion which avoids taking turns:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">FALSE</span>  <span class=\"token expression\"><span class=\"token number\">0</span></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">TRUE</span> <span class=\"token expression\"><span class=\"token number\">1</span></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">N</span> <span class=\"token expression\"><span class=\"token number\">2</span> </span><span class=\"token comment\">/* number of processes */</span></span>\n<span class=\"token keyword\">int</span> turn<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* whose turn is it? */</span>\n<span class=\"token keyword\">int</span> interested<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* all values initially 0 (FALSE) */</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">enter_region</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> process<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* process is 0 or 1 */</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> other<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* number of the other process */</span>\n    other <span class=\"token operator\">=</span> <span class=\"token number\">1</span> − process<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* the opposite of process */</span>\n    interested<span class=\"token punctuation\">[</span>process<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> TRUE<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* show that you are interested */</span>\n    turn <span class=\"token operator\">=</span> process<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* set flag */</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>turn <span class=\"token operator\">==</span> process <span class=\"token operator\">&amp;&amp;</span> interested<span class=\"token punctuation\">[</span>other<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> TRUE<span class=\"token punctuation\">)</span>  <span class=\"token comment\">/* null statement */</span> <span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">leave_region</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> process<span class=\"token punctuation\">)</span> <span class=\"token comment\">/* process: who is leaving */</span>\n<span class=\"token punctuation\">{</span>\n    interested<span class=\"token punctuation\">[</span>process<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> FALSE<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* indicate departure from critical region */</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"Hardware-instructions\">Hardware instructions</h2>\n<p>Many processors nowadays support instructions that are \n          <span class=\"keyword-link\" id=\"keyword-link-atomic\">\n          atomic\n          </span>\n          . This instruction is the TSL (Test and Set Lock). The instruction guarantees that no other process can access the memory word until the instruction has finished, so the instruction effectively blocks the memory bus until it is finished to prohibit other processes to access it while it is active. XCHG is another such instruction which exchanges the contents of two locations in an atomic way.</p>\n<h1 id=\"Mutual-exclusion-that-blocks\">Mutual exclusion that blocks</h1>\n<p>To avoid wasting CPU resources when a process is waiting for the lock we need to come up with another solution. A simple solution is to use <code class=\"language-text\">sleep()</code> and <code class=\"language-text\">wakeup()</code></p>\n<h1 id=\"Semaphores\">Semaphores</h1>\n<p>A semaphore has a value where 0 represent that no wakeups were saved or above 0 which indicates that more than 0 wakeups are pending. Usually incrementing and decrementing are done through operations called <code class=\"language-text\">up</code> and <code class=\"language-text\">down</code>. These actions are executed in an atomic manner. The normal way to implement them as that is through system calls with the operating system briefly disabling all the interrupts while accessing the semaphore. Disabling all interrupts here should be of no harm because the access is only a few instructions. If the processor consists of multiple CPUs each semaphore should be protected by a lock variable as well with the hardware instructions (e.g. <code class=\"language-text\">TSL</code>).</p>\n<h1 id=\"Mutex\">Mutex</h1>\n<p>A mutex is a simplified version of a semaphore when counting is not needed. They are only good for managing mutual exclusion. They can have two states: unlocked or locked. They can be implemented in user space if hardware instructions like <code class=\"language-text\">TSL</code> are available.</p>\n<div class=\"gatsby-highlight\" data-language=\"assembly\"><pre class=\"language-assembly\"><code class=\"language-assembly\">mutex_lock:\n    TSL REGISTER,MUTEX      % copy mutex to register and set mutex to 1\n    CMP REGISTER,#0         % was mutex zero?\n    JZE ok                  % if it was zero, mutex was unlocked, so return\n    CALL thread_yield       % mutex is busy; schedule another thread\n    JMP mutex_lock          % try again\nok: RET                     % return to caller; critical region entered\n\nmutex_unlock:\n    MOVE MUTEX,#0           % store a 0 in mutex\n    RET                     % return to caller</code></pre></div>\n<p>We can see that if a process can not acquire the mutex, it will yield instead of busy waiting. This is especially important in user threads, because there is no clock that could stop threads that have run for too long. Thus a thread trying to acquire a lock by busy waiting will run forever and never acquire the lock, blocking other threads from being run.</p>\n<h1 id=\"Avoid-locks\">Avoid locks</h1>\n<p>We could let readers read the old or new version of the modified shared data while a writer writes to it, instead of a weird combination.</p>\n<h1 id=\"Deadlock\">Deadlock</h1>\n<p>Four conditions must hold for there to be a resource deadlock:</p>\n<ol>\n<li><strong>Mutual exclusion</strong>. A resource is assigned to <strong>one</strong> process or is available.</li>\n<li><strong>Hold-and-wait</strong>. Processes already holding resources may request more resources.</li>\n<li><strong>No-preemption</strong>. Resources cannot be taken away from a process forcibly, only explicitly released.</li>\n<li><strong>Circular wait</strong>. Two or more processes form a chain where each process waits for resources already held by other processes in that chain.</li>\n</ol>\n<p>There are in general four strategies for dealing with deadlocks:</p>\n<ol>\n<li>Ignore the problem and hope it will ignore you too.</li>\n<li>Let them occur and take appropriate actions to handle the situation.</li>\n<li>Careful resource allocation.</li>\n<li>Negating one of the conditions above.</li>\n</ol>\n<p>Lets take a closer look at the fourth strategy, negating on of the four conditions. Lets begin by negating the first condition <strong>mutual exclusion</strong>. To make a resource accessible to more than one process at a time would be to make the data read-only. The key insight here is to only assign a resource when absolutely necessary and keep as few processes as possible from accessing that resource. If we try to negate <strong>hold-and-wait</strong> instead we could for example let every process request all their resources from the start, if everything is available the process can proceed completing its execution, else the process will just wait. However it can be hard to know what resources a process needs and resources may not be used in an optimal manner. If we try to negate <strong>no-preemption</strong> we could forcibly take every needed resource, but this could be impossible at worst. To negate <strong>circular wait</strong> we could restrain each process to only hold a single resource at a time. Before requesting access to a new resource it must release the resource it is currently holding. This may be unacceptable if the second resource request depend on the resource the process is currently holding. We could introduce a global accessing table which tells the order a process may access resources. Thus every process that wants to request resource <span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> must request resource <span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> first.</p>\n<div class=\"reference-items\"></div>","frontmatter":{"slug":"/os/interprocess-communication","tags":[],"lastModified":"2022-03-31","created":"2021-09-28","title":"Interprocess Communication","header":[{"depth":1,"name":"Critical regions","link":"Critical-regions"},{"depth":1,"name":"Mutual exclusion with busy waiting","link":"Mutual-exclusion-with-busy-waiting"},{"depth":2,"name":"Hardware instructions","link":"Hardware-instructions"},{"depth":1,"name":"Mutual exclusion that blocks","link":"Mutual-exclusion-that-blocks"},{"depth":1,"name":"Semaphores","link":"Semaphores"},{"depth":1,"name":"Mutex","link":"Mutex"},{"depth":1,"name":"Avoid locks","link":"Avoid-locks"},{"depth":1,"name":"Deadlock","link":"Deadlock"}]}}},"pageContext":{"slug":"/os/interprocess-communication"}},"staticQueryHashes":[]}