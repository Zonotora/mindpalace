{"componentChunkName":"component---src-templates-file-js","path":"/os/memory-management","result":{"data":{"markdownRemark":{"html":"<h1 id=\"Physical-memory\">Physical memory</h1>\n<p>The first computers had no memory abstractions whatsoever. Thus accessing the memory was actually accessing the phsyical memory in the requested location. However having to programs running at the same time became a challenge, because one program would most certainly overwrite a memory location that the other program used leading to crashes. One way to overcome this is \n          <span class=\"keyword-link\" id=\"keyword-link-static-relocation\">\n          static relocation\n          </span>\n          , but it is slow and tricky to implement. However the operating system could run multiple programs concurrently even without memory abstractions. The way it would do so is saving the entire contents of memory to a dist file, \n          <span class=\"keyword-link\" id=\"keyword-link-swapping\">\n          swapping\n          </span>\n          , and put in another program. In this way only one program would have access to the memory at a given time. Another problem to take into consideration is that if a user program could access every memory location it could intentionally or by accident overwrite the memory of the operating system unless there is some locking mechanisms.</p>\n<h1 id=\"Address-space\">Address space</h1>\n<p>So how to we solve <strong>protection</strong> and <strong>relocation</strong> of memory? By introducting a new abstract called the <strong>address space</strong>. The address space is a set of addresses that is a process can use to access memory. It is also unique for that process unless, in some occasions, some processes want to share their address spaces. A simple solution to map each process' address space to the physical memory is to use to special registers, <strong>base</strong> and <strong>limit</strong>. The base register holds the physical address assigned to a program and the limit register the length of that program. Thus if two programs are loaded into memory at the same time, the second program would have the base as the length of first program. When these programs are executed and a memory instruction is referenced the hardware automatically adds the base value to that memory reference before executing it. If the new value is above the limit or below the base of that program a fault is generated. The obvious disadvantage of this is that for every memory instruction additional computation is required.</p>\n<h1 id=\"Swapping\">Swapping</h1>\n<p>In practice the total memory needed for all processes that are running concurrently often exceeds the amount of \n          <span class=\"keyword-link\" id=\"keyword-link-ram\">\n          RAM\n          </span>\n          . To deal with this two approaches are used, swapping and virtual memory. Swapping involves bringing in each process to memory, run it for some time, and the put it back on the disk. Virtual memory on the other hand allows each process to run even though they are partially in memory. So how much memory needs to be allocated for a process when swapping? If every process is created with a fixed size the operating systems knows how much memory is needed and allocates exactly that amount. But if the process contains dynamic elements allowing the \n          <span class=\"keyword-link\" id=\"keyword-link-data-segment\">\n          data segment\n          </span>\n           to grow the problem becomes much more complicated. If a memory hole, created by swapping in and out different processes, are located next to a process that could easily be allocated for the program to hold dynamic elements. If it can't grow it has to move to a memory hole that is big enough or other processes have to be swapped out to create a space big enough. If the swap area is full as well when a process can't grow it is suspended until enough space is available or killed. Thus it can be a good idea to allocate some extra memory for each process to reduce overhead in swapping and moving processes around. But we should only swap the memory in use, and not the extra allocated memory.</p>\n<p>When memory is dynamically used the operating system must keep track of it either by \n          <span class=\"keyword-link\" id=\"keyword-link-bitmaps\">\n          bitmaps\n          </span>\n           or \n          <span class=\"keyword-link\" id=\"keyword-link-free-lists\">\n          free lists\n          </span>\n          . The bitmap divide the memory into allocation units where each unit corresponds to a bit, 0 if the unit is free or 1 if it is used. There is a tradeoff of how big these allocations units should be. The operating system could also maintain a linked list of all the allocated memory and available memory. When the list is sorted by addresses several algorithms exist to allocate the memory. The simplest algorithm is called first fit. It just scan the list until it finds a memory segment big enough. A variation of the first fit algorithm is the next fit. It extends first fit by keeping track of every hole it encounters to that the next time it searches it begins at such a hole. However simulations have showed that next fit gives worse performance than first fit. Yet another approach is best fit. It searches every possible hole and take the smallest. An alternative is also worst fit which takes the biggest available memory but it is not very good. Another is quick fit which keeps track of commonly requested sizes in a separate list. All of these algorithms have the disadvantage that when a process is swapped out or terminated it could possibly be quite expensive to check if a merge of the newly available memory to already existing adjacent holes could be done.</p>\n<h1 id=\"Segmentation\">Segmentation</h1>\n<p>A segment is an independent address space used to manage the growing and shrinking data structures. It also simplifies linking if procedures occupy seperate segments, because then the start address is same for all procedures (0) and we need only the segment number to call the procedure. If a procedure changes no other procedure needs to change due to the fact that the start address does not change. This is not the case if this technique is not used, because then procedures may be tightly packed next to each other and changing the size of one procedure may change the whole structure. A segment consists of linear addresses starting from 0 up to same maximum value which can change at execution. To specify an address the program must provide a segment number and an address within the segment. Segmentation makes it easier to share data and procedures between processes.</p>\n<div class=\"reference-items\"></div>","frontmatter":{"slug":"/os/memory-management","tags":[],"lastModified":"2021-10-13","created":"2021-10-05","title":"Memory Management","header":[{"depth":1,"name":"Physical memory","link":"Physical-memory"},{"depth":1,"name":"Address space","link":"Address-space"},{"depth":1,"name":"Swapping","link":"Swapping"},{"depth":1,"name":"Segmentation","link":"Segmentation"}]}}},"pageContext":{"slug":"/os/memory-management"}},"staticQueryHashes":[]}